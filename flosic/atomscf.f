C UTEP Electronic Structure Lab (2019)
C
      SUBROUTINE ATOMSCF(IFNCT)
        use mesh1,only : wmsh,rmsh,nmsh
       use common1,only : PSPSYM, RPSNLO, WPSNLO, VPSNLO, LMAXNLO, NRPSP
       use common2,only : RCNT, IFUCNT, NCNT, ZELC, BFCON, BFALP,
     &   N_BARE, N_CON, LSYMMAX, IGGA, NSPN
       use common3,only : RMAT, NGRP
       use common4,only : RPFALP, RPFCMX, RPFCOF, NRPFIT, LDIVR
       use common5,only : CONVERGENCE
       use common8,only : IGEN
       use global_inputs, only : libxc1   !YY. this is for subvlxc_atomscf
! Conversion to implicit none.  Raja Zope Thu Aug 17 14:34:34 MDT 2017

!      INCLUDE  'PARAMAS'  
       INCLUDE  'PARAMA2'  
       INTEGER :: IFNCT, I, IBARE, ICON, IERR, IFAIL, IOFS, IR, IRAD,
     & ISTA, ISTEP, ITER, JCON, JRAD, L, L1, LPSPMX, MATSZ, MAXRAD,
     & NCOUL, NIFUCNT, NNCNT, NNGRP, NNSPN, NRAD, NSTATES, NSTEP
       REAL*8 :: SYMBOL , ALMAX, ALMIN, ALONG, ALP, AMIX, DLTX, EFERM,
     & ELEC, ERROR, EVTR, FAC, PI, POTF, R2, RHOF, RINFTY, RLIMT, RLW,
     & RR, RRC, RUP, SCFTATM, SMALL, SUM, TEMP, TROLD, WF0, WF1, WF2,
     & WFAC, X, ZZ
       real*8  :: rcutoff
       external  rcutoff
       SAVE
       PARAMETER (MAXRAD=500)
       PARAMETER (NCOUL=5)
       PARAMETER (MATSZ=MAXLSQF)
C       COMMON/TMP1/OVLTAB(MAX_CON,MAX_CON,LDIM),OVLDIA(MAX_CON,LDIM)
C     &  ,HKNTAB(MAX_CON,MAX_CON,LDIM),HNLTAB(MAX_CON,MAX_CON,LDIM)
C     &  ,BASFU(3,MAX_CON),TABEXP(MAX_BARE)
C     &  ,RRAD(MAXRAD),WRAD(MAXRAD),VLOC(MAXRAD),VPOT(2,MAXRAD)
C     &  ,VXCSUB(2),VXC(MAXRAD),RHO(5,MAXRAD),RHCL(NCOUL,3),RHOGRD(10)
C     &  ,HMAT(MAX_CON,MAX_CON,LDIM),OMAT(MAX_CON,MAX_CON,LDIM)
C     &  ,EVALA(MAX_CON,LDIM),SCRV(MAX_CON),RPW(5),ORCNT(3),EXCVEC(4)
C     &  ,EVTB(MAX_CON*LDIM),OCCU(MAX_CON*LDIM)
C     &  ,AMAT(MATSZ,MATSZ),AVEC(MATSZ),FCOF(MATSZ)
C     &  ,NDEG(MAX_CON*LDIM),IVEC(MATSZ),NIGGA(2)
       REAL*8 :: VXCSUB(2),RHOGRD(10),RPW(5),ORCNT(5),EXCVEC(4)
       INTEGER :: NIGGA(2)
       REAL*8,ALLOCATABLE :: OVLTAB(:,:,:),OVLDIA(:,:),HKNTAB(:,:,:),
     &  HNLTAB(:,:,:),BASFU(:,:),TABEXP(:),RRAD(:),WRAD(:),VLOC(:),
     &  VPOT(:,:),VXC(:),RHO(:,:),RHCL(:,:),HMAT(:,:,:),SCRV(:),EVTB(:),
     &  OCCU(:),AMAT(:,:),AVEC(:),FCOF(:),OMAT(:,:,:),EVALA(:,:)
       INTEGER,ALLOCATABLE :: NDEG(:),IVEC(:)
       DATA SCFTATM /1.0D-5/
       DATA SMALL   /1.0D-5/
C
C ALLOCATION OF LOCAL ARRAYS (NEED TO CHECK TO SEE IF THIS IS COUNTERPRODUCTIVE TIMEWISE)
C
       rewind(321)
       ALLOCATE(OVLTAB(MAX_CON,MAX_CON,LDIM),STAT=IERR)
       IF(IERR.NE.0)THEN
          WRITE(6,*)'ATOMSCF:ERROR ALLOCATING OVLTAB'
       ENDIF
       ALLOCATE(OVLDIA(MAX_CON,LDIM),STAT=IERR)
       IF(IERR.NE.0)THEN
          WRITE(6,*)'ATOMSCF:ERROR ALLOCATING OVLDIA'
       ENDIF
       ALLOCATE(HKNTAB(MAX_CON,MAX_CON,LDIM),STAT=IERR)
       IF(IERR.NE.0)THEN
          WRITE(6,*)'ATOMSCF:ERROR ALLOCATING HKNTAB'
       ENDIF
       ALLOCATE(HNLTAB(MAX_CON,MAX_CON,LDIM),STAT=IERR)
       IF(IERR.NE.0)THEN
          WRITE(6,*)'ATOMSCF:ERROR ALLOCATING HNLTAB'
       ENDIF
       ALLOCATE(BASFU(3,MAX_CON),STAT=IERR)
       IF(IERR.NE.0)THEN
          WRITE(6,*)'ATOMSCF:ERROR ALLOCATING BASFU'
       ENDIF
       ALLOCATE(TABEXP(MAX_BARE),STAT=IERR)
       IF(IERR.NE.0)THEN
          WRITE(6,*)'ATOMSCF:ERROR ALLOCATING TABEXP'
       ENDIF
       ALLOCATE(RRAD(MAXRAD),STAT=IERR)
       IF(IERR.NE.0)THEN
          WRITE(6,*)'ATOMSCF:ERROR ALLOCATING MAXRAD'
       ENDIF
       ALLOCATE(WRAD(MAXRAD),STAT=IERR)
       IF(IERR.NE.0)THEN
          WRITE(6,*)'ATOMSCF:ERROR ALLOCATING WRAD'
       ENDIF
       ALLOCATE(VLOC(MAXRAD),STAT=IERR)
       IF(IERR.NE.0)THEN
          WRITE(6,*)'ATOMSCF:ERROR ALLOCATING VLOC'
       ENDIF
       ALLOCATE(VPOT(2,MAXRAD),STAT=IERR)
       IF(IERR.NE.0)THEN
          WRITE(6,*)'ATOMSCF:ERROR ALLOCATING VPOT'
       ENDIF
       ALLOCATE(VXC(MAXRAD),STAT=IERR)
       IF(IERR.NE.0)THEN
          WRITE(6,*)'ATOMSCF:ERROR ALLOCATING VXC'
       ENDIF
       ALLOCATE(RHO(5,MAXRAD),STAT=IERR)
       IF(IERR.NE.0)THEN
          WRITE(6,*)'ATOMSCF:ERROR ALLOCATING RHO'
       ENDIF
       ALLOCATE(RHCL(NCOUL,3),STAT=IERR)
       IF(IERR.NE.0)THEN
          WRITE(6,*)'ATOMSCF:ERROR ALLOCATING RHCL'
       ENDIF
       ALLOCATE(HMAT(MAX_CON,MAX_CON,LDIM),STAT=IERR)
       IF(IERR.NE.0)THEN
          WRITE(6,*)'ATOMSCF:ERROR ALLOCATING HMAT'
       ENDIF
       ALLOCATE(OMAT(MAX_CON,MAX_CON,LDIM),STAT=IERR)
       IF(IERR.NE.0)THEN
          WRITE(6,*)'ATOMSCF:ERROR ALLOCATING OMAT'
       ENDIF
       ALLOCATE(EVALA(MAX_CON,LDIM),STAT=IERR)
       IF(IERR.NE.0)THEN
          WRITE(6,*)'ATOMSCF:ERROR ALLOCATING EVALA'
       ENDIF
       ALLOCATE(SCRV(MAX_CON),STAT=IERR)
       IF(IERR.NE.0)THEN
          WRITE(6,*)'ATOMSCF:ERROR ALLOCATING SCRV'
       ENDIF
       ALLOCATE(EVTB(MAX_CON*LDIM),STAT=IERR)
       IF(IERR.NE.0)THEN
          WRITE(6,*)'ATOMSCF:ERROR ALLOCATING EVTB'
       ENDIF
       ALLOCATE(OCCU(MAX_CON*LDIM),STAT=IERR)
       IF(IERR.NE.0)THEN
          WRITE(6,*)'ATOMSCF:ERROR ALLOCATING OCCU'
       ENDIF
       ALLOCATE(AMAT(MATSZ,MATSZ),STAT=IERR)
       IF(IERR.NE.0)THEN
          WRITE(6,*)'ATOMSCF:ERROR ALLOCATING AMAT'
       ENDIF
       ALLOCATE(AVEC(MATSZ),STAT=IERR)
       IF(IERR.NE.0)THEN
          WRITE(6,*)'ATOMSCF:ERROR ALLOCATING MATSZ'
       ENDIF
       ALLOCATE(FCOF(MATSZ),STAT=IERR)
       IF(IERR.NE.0)THEN
          WRITE(6,*)'ATOMSCF:ERROR ALLOCATING FCOF'
       ENDIF
       ALLOCATE(NDEG(MAX_CON*LDIM),STAT=IERR)
       IF(IERR.NE.0)THEN
          WRITE(6,*)'ATOMSCF:ERROR ALLOCATING NDEG'
       ENDIF
       ALLOCATE(IVEC(MATSZ),STAT=IERR)
       IF(IERR.NE.0)THEN
          WRITE(6,*)'ATOMSCF:ERROR ALLOCATING IVEC'
       ENDIF

C
C SETUP
C
       PI= 4*ATAN(1.0D0)
       IF (MAX_PTS .LT. 1) THEN
        PRINT *,'ATOMSCF: MAX_PTS MUST BE > 0'
        CALL STOPIT
       END IF
C
C GET SMALLEST AND LARGEST EXPONENTS
C
       ALMIN=  1.0D30
       ALMAX= -1.0D30
       DO I= 1,N_BARE(IFNCT)
        ALMIN= MIN(ALMIN,BFALP(I,IFNCT))
        ALMAX= MAX(ALMAX,BFALP(I,IFNCT))
       END DO
       ALMIN= 2*ALMIN
       ALMAX= 2*ALMAX
C
C IF ZELC IS ZERO, DEFINE STANDARD POTENTIAL AND DENSITY
C
       IF (ZELC(IFNCT) .LT. SMALL) THEN
        PRINT '(A,I3,A)','ATOM TYPE ',IFNCT,' HAS NO ELECTRONS'
        NRPFIT(IFNCT)= 0
        LDIVR(IFNCT)= 0
        RETURN
       END IF
C
C SAVE VARIABLES THAT HAVE TO BE CHANGED TO MAKE GETVLXC WORK
C
       NIGGA(1)= IGGA(1)
       NIGGA(2)= IGGA(2)
       IGGA(1)= 0
       IGGA(2)= 0
       NNCNT= NCNT
       NCNT= 1
       NIFUCNT= IFUCNT(1)
       IFUCNT(1)= IFNCT
       ORCNT(1)= RCNT(1,1)
       ORCNT(2)= RCNT(2,1)
       ORCNT(3)= RCNT(3,1)
       RCNT(1,1)= 0.0D0
       RCNT(2,1)= 0.0D0
       RCNT(3,1)= 0.0D0
       NNGRP= NGRP
       NGRP= 1
       NNSPN= NSPN
       NSPN= 1
C
C GET OVERLAP, KINETIC ENERGY, AND NONLOCAL POTENTIAL MATRIX ELEMENTS
C
       CALL OVLATM(IFNCT,OVLTAB)
       CALL HKNATM(IFNCT,HKNTAB)
       DO L= 0,LSYMMAX(IFNCT)
        L1= L+1
        DO ICON= 1,N_CON(L1,IFNCT)
         OVLDIA(ICON,L1)= OVLTAB(ICON,ICON,L1)
        END DO
       END DO
C
C GET NONLOCAL POTENTIAL MATRIX ELEMENTS
C
       DO L= 0,LSYMMAX(IFNCT)
        L1= L+1
        DO ICON= 1,N_CON(L1,IFNCT)
         DO JCON= ICON,N_CON(L1,IFNCT)
          HNLTAB(JCON,ICON,L1)= 0.0D0
         END DO
        END DO
       END DO
C
       IF (PSPSYM(IFNCT)(1:3) .NE. 'ALL') THEN
        LPSPMX= MIN(LSYMMAX(IFNCT),LMAXNLO(IFNCT))
        DO IRAD= 1,NRPSP(IFNCT)
         RR= RPSNLO(IRAD,IFNCT) 
         R2= RR*RR
         WFAC= 4*PI*WPSNLO(IRAD,IFNCT)
         DO IBARE= 1,N_BARE(IFNCT)
          TABEXP(IBARE)= EXP(-BFALP(IBARE,IFNCT)*R2)
         END DO
         RPW(1)= 1.0D0
         DO L= 0,LPSPMX
          L1= L+1
          DO ICON= 1,N_CON(L1,IFNCT)
           SUM= 0.0D0
           DO IBARE= 1,N_BARE(IFNCT)
            SUM= SUM+BFCON(IBARE,ICON,L1,IFNCT)*TABEXP(IBARE)
           END DO
           BASFU(1,ICON)= RPW(1)*SUM
          END DO
          DO ICON= 1,N_CON(L1,IFNCT)
           DO JCON= ICON,N_CON(L1,IFNCT)
            HNLTAB(JCON,ICON,L1)= HNLTAB(JCON,ICON,L1)
     &      +WFAC*BASFU(1,ICON)*BASFU(1,JCON)*VPSNLO(L1,IRAD,IFNCT)
           END DO
          END DO
          RPW(1)= RPW(1)*RR
         END DO
        END DO
       END IF
C
C GET ACCURATE RADIAL MESH 
C DEFINE LOCAL AND INITIAL POTENTIAL 
C
       ALONG= 1.0D30
       DO I= 1,N_BARE(IFNCT)
        ALONG= MIN(ALONG,BFALP(I,IFNCT))
       END DO
       ERROR= 1.0D-8
       RINFTY= RCUTOFF(2*LSYMMAX(IFNCT)+2,2*ALONG,ERROR)
       CALL OPTRMSH(MAXRAD,IFNCT,0.0D0,RINFTY,OVLDIA,ERROR,
     &              NRAD,RRAD,WRAD)
       DO IRAD= 1,NRAD
        CALL VLOCAL(1,1,IFNCT,RRAD(IRAD),VLOC(IRAD))
        VPOT(1,IRAD)= VLOC(IRAD)*EXP(-RRAD(IRAD))
       END DO
C
C ITERATIONS
C
       ITER= 0
       TROLD= 1.0D30
  100  CONTINUE
        ITER= ITER+1
C
C FOR EACH ANGULAR MOMENTUM, BUILD HAMILTONIAN MATRIX AND DIAGONALIZE
C
        NSTATES= 0
        DO L= 0,LSYMMAX(IFNCT)
         L1= L+1
         DO ICON= 1,N_CON(L1,IFNCT)
          DO JCON= ICON,N_CON(L1,IFNCT)
           HMAT(JCON,ICON,L1)= 0.0D0
          END DO
         END DO
         DO IRAD= 1,NRAD
          RR= RRAD(IRAD)
          R2= RR*RR
          RPW(1)= 1.0D0
          DO I= 1,L
           RPW(1)= RPW(1)*RR
          END DO
          WFAC= 4*PI*WRAD(IRAD)
          DO IBARE= 1,N_BARE(IFNCT)
           TABEXP(IBARE)= EXP(-BFALP(IBARE,IFNCT)*R2)
          END DO
          DO ICON= 1,N_CON(L1,IFNCT)
           SUM= 0.0D0
           DO IBARE= 1,N_BARE(IFNCT)
            SUM= SUM+BFCON(IBARE,ICON,L1,IFNCT)*TABEXP(IBARE)
           END DO
           BASFU(1,ICON)= RPW(1)*SUM
          END DO
          DO ICON= 1,N_CON(L1,IFNCT)
           DO JCON= ICON,N_CON(L1,IFNCT)
            HMAT(JCON,ICON,L1)= HMAT(JCON,ICON,L1)
     &      +WFAC*BASFU(1,ICON)*BASFU(1,JCON)*VPOT(1,IRAD)
           END DO
          END DO
         END DO
         DO ICON= 1,N_CON(L1,IFNCT)
          DO JCON= ICON,N_CON(L1,IFNCT)
           HMAT(JCON,ICON,L1)= HMAT(JCON,ICON,L1)
     &     +HNLTAB(JCON,ICON,L1)+HKNTAB(JCON,ICON,L1)
           HMAT(ICON,JCON,L1)= HMAT(JCON,ICON,L1)
           OMAT(JCON,ICON,L1)= OVLTAB(JCON,ICON,L1)
           OMAT(ICON,JCON,L1)= OVLTAB(JCON,ICON,L1)
          END DO
         END DO
       CALL DIAGGE_FO(MAX_CON,N_CON(L1,IFNCT),HMAT(1,1,L1),OMAT(1,1,L1),
     &               EVALA(1,L1),SCRV,1)
         DO ICON= 1,N_CON(L1,IFNCT)
          NSTATES= NSTATES+1
          EVTB(NSTATES)= EVALA(ICON,L1)
          NDEG(NSTATES)= 4*L+2
         END DO
        END DO
C
C DEFINE OCCUPATION NUMBERS
C
        ELEC= ZELC(IFNCT)
        TEMP= 0.01D0
!YY using fermilv from the SIC code. 
        CALL FERMILV_SIC(NSTATES,ELEC,EFERM,TEMP,EVTB,OCCU,NDEG)
        DO I= 1,NSTATES
         OCCU(I)= OCCU(I)*NDEG(I)
        END DO
C
C GET EIGENVALUE TRACE 
C
        EVTR= 0.0D0
        DO I= 1,NSTATES
         EVTR= EVTR+EVTB(I)*OCCU(I)
        END DO
C
C GET DENSITY AND ITS DERIVATIVES AND INTEGRALS ON MESH
C
        DO IRAD= 1,NRAD
         RHO(1,IRAD)= 0.0D0
         RHO(2,IRAD)= 0.0D0
         RHO(3,IRAD)= 0.0D0
         RR= RRAD(IRAD)
         R2= RR*RR
         DO IBARE= 1,N_BARE(IFNCT)
          TABEXP(IBARE)= EXP(-BFALP(IBARE,IFNCT)*R2)
         END DO
         RPW(1)= 0.0D0
         RPW(2)= 0.0D0
         RPW(3)= 1.0D0
         RPW(4)= RR
         RPW(5)= R2
         IOFS= 0
         DO L= 0,LSYMMAX(IFNCT)
          L1= L+1
          DO ICON= 1,N_CON(L1,IFNCT)
           BASFU(1,ICON)= 0.0D0
           BASFU(2,ICON)= 0.0D0
           BASFU(3,ICON)= 0.0D0
           DO IBARE= 1,N_BARE(IFNCT)
            ALP= BFALP(IBARE,IFNCT)
            FAC= BFCON(IBARE,ICON,L1,IFNCT)*TABEXP(IBARE)
            BASFU(1,ICON)= BASFU(1,ICON)+FAC*RPW(3)
            BASFU(2,ICON)= BASFU(2,ICON)+FAC*(L*RPW(2)-2*ALP*RPW(4))
            BASFU(3,ICON)= BASFU(3,ICON)
     &      +FAC*(L*(L-1)*RPW(1)-2*ALP*((2*L+1)*RPW(3)-2*ALP*RPW(5)))
           END DO
          END DO
          DO I= 1,4
           RPW(I)= RPW(I+1)
          END DO
          RPW(5)= RPW(5)*RR
          DO ISTA= 1,N_CON(L1,IFNCT)
           WF0= 0.0D0
           WF1= 0.0D0
           WF2= 0.0D0
           DO ICON= 1,N_CON(L1,IFNCT)
            WF0= WF0+HMAT(ICON,ISTA,L1)*BASFU(1,ICON)
            WF1= WF1+HMAT(ICON,ISTA,L1)*BASFU(2,ICON)
            WF2= WF2+HMAT(ICON,ISTA,L1)*BASFU(3,ICON)
           END DO
           RHO(1,IRAD)= RHO(1,IRAD)+OCCU(IOFS+ISTA)*WF0*WF0 !Density
           RHO(2,IRAD)= RHO(2,IRAD)+OCCU(IOFS+ISTA)*WF0*WF1*2 !Derivative
           RHO(3,IRAD)= RHO(3,IRAD)+OCCU(IOFS+ISTA)*(WF1*WF1+WF0*WF2)*2 !This looks like 2nd derivative 
          END DO
          IOFS= IOFS+N_CON(L1,IFNCT)
         END DO
C
C INTEGRALS (FOR COULOMB-POT)
C
         RLW= 0.0D0
         IF (IRAD .GT. 1) RLW= RRAD(IRAD-1)
         RUP= RRAD(IRAD)
         CALL GAUSSP(RLW,RUP,NCOUL,RHCL(1,1),RHCL(1,2))
         DO JRAD= 1,NCOUL
          RHCL(JRAD,3)= 0.0D0
          RR= RHCL(JRAD,1)
          R2= RR*RR
          DO IBARE= 1,N_BARE(IFNCT)
           TABEXP(IBARE)= EXP(-BFALP(IBARE,IFNCT)*R2)
          END DO
          RPW(1)= 1.0D0
          IOFS= 0
          DO L= 0,LSYMMAX(IFNCT)
           L1= L+1
           DO ICON= 1,N_CON(L1,IFNCT)
            BASFU(1,ICON)= 0.0D0
            DO IBARE= 1,N_BARE(IFNCT)
             FAC= BFCON(IBARE,ICON,L1,IFNCT)*TABEXP(IBARE)
             BASFU(1,ICON)= BASFU(1,ICON)+FAC*RPW(1)
            END DO
           END DO
           RPW(1)= RPW(1)*RR
           DO ISTA= 1,N_CON(L1,IFNCT)
            WF0= 0.0D0
            DO ICON= 1,N_CON(L1,IFNCT)
             WF0= WF0+HMAT(ICON,ISTA,L1)*BASFU(1,ICON)
            END DO
            RHCL(JRAD,3)= RHCL(JRAD,3)+OCCU(IOFS+ISTA)*WF0*WF0
           END DO
           IOFS= IOFS+N_CON(L1,IFNCT)
          END DO
         END DO
         RHO(4,IRAD)= 0.0D0
         RHO(5,IRAD)= 0.0D0
         DO JRAD= 1,NCOUL
          RHO(4,IRAD)= RHO(4,IRAD)
     &                +RHCL(JRAD,2)*RHCL(JRAD,3)*RHCL(JRAD,1)
          RHO(5,IRAD)= RHO(5,IRAD)
     &                +RHCL(JRAD,2)*RHCL(JRAD,3)*RHCL(JRAD,1)**2
         END DO
        END DO
C
C GET EXCHANGE-CORRELATION POTENTIAL: USE SUBVLXC WITH MODE 1
C WHICH DOESN'T CALCULATE THE LOCAL POTENTIAL
C
!YY. I don't know why you need 10 RHOGRD elements when you
!only use RHOGRD(1)
        NMSH= 1
        RMSH(1,1)= 0.0D0 
        RMSH(2,1)= 0.0D0 
        WMSH(1)= 0.0D0
        RHOGRD( 2)= 0.0D0
        RHOGRD( 3)= 0.0D0
        RHOGRD( 8)= 0.0D0
        RHOGRD( 9)= 0.0D0
        RHOGRD(10)= 0.0D0
!YY. Use subvlxc_atomscf if libxc1 is .ture.
        call CHECK_INPUTS
        DO IRAD= 1,NRAD
         RRC= 1.0D0/RRAD(IRAD)
         RMSH(3,1)= RRAD(IRAD)
         RHOGRD( 1)= RHO(1,IRAD)
         RHOGRD( 4)= RHO(2,IRAD)
         RHOGRD( 5)= RHO(2,IRAD)*RRC  
         RHOGRD( 6)= RHO(2,IRAD)*RRC  
         RHOGRD( 7)= RHO(3,IRAD)
         if(libxc1) then
            call ATOMSCFVLXC(RHOGRD,VXCSUB,EXCVEC,NIGGA)
         !else if(NIGGA(1) >= 2 .or. NIGGA(2) >= 2) then
         else if(NIGGA(1) == 3 .or. NIGGA(2) == 3) then
            call ATOMSCFVLXC(RHOGRD,VXCSUB,EXCVEC,NIGGA)
         else
            CALL SUBVLXC(1,0,1,RHOGRD,VXCSUB,VLOC,EXCVEC,.true.,-1,0,0)
         end if
         VXC(IRAD)= VXCSUB(1)
        END DO
C
C COULOMB POTENTIAL
C        
        DO IRAD= 2,NRAD
         RHO(4,NRAD-IRAD+1)= RHO(4,NRAD-IRAD+1)+RHO(4,NRAD-IRAD+2)
         RHO(5,IRAD)= RHO(5,IRAD)+RHO(5,IRAD-1)
        END DO
        DO IRAD= 1,NRAD-1
         VPOT(2,IRAD)= 4*PI*(RHO(4,IRAD+1)+RHO(5,IRAD)/RRAD(IRAD))
        END DO
        VPOT(2,NRAD)= 4*PI*RHO(5,NRAD)/RRAD(NRAD)
C
C PUTTING IT ALL TOGETHER
C
        DO IRAD= 1,NRAD
         VPOT(2,IRAD)= VPOT(2,IRAD)+VXC(IRAD)+VLOC(IRAD)
        END DO
C
C CHECK FOR CONVERGENCE
C
        IF (ABS(EVTR-TROLD) .LT. SCFTATM) GOTO 200
        TROLD= EVTR
C
C SLIGHTLY BETTER THAN SIMPLE MIXING
C
        IF (ITER .EQ. 1) THEN
         DO IRAD= 1,NRAD
          VPOT(1,IRAD)= VPOT(2,IRAD)
         END DO
        ELSE 
         AMIX= 0.10D0
         DO IRAD= 1,NRAD
          VPOT(1,IRAD)= (1.0D0-AMIX)*VPOT(1,IRAD)+AMIX*VPOT(2,IRAD)
         END DO
        END IF
        GOTO 100
  200  CONTINUE
       PRINT '(A,I3,2A)','SCF FOR ATOM TYPE ',IFNCT,' SUCCESSFUL, ',
     &                   'EIGENVALUES: '
       DO L= 0,LSYMMAX(IFNCT)
        L1= L+1
        PRINT 1010,(EVALA(I,L1), I= 1,N_CON(L1,IFNCT))
 1010   FORMAT(5(1X,F12.5))
       END DO
C
C UPDATE ALMIN (TAKE RHO**(1/3) BEHAVIOR OF EXC INTO ACCOUNT)
C
       ALMIN= 0.335D0*ALMIN
       RPFALP(IFNCT)= ALMIN
       I= 0
       X= ALMIN
  210  CONTINUE
        I= I+1
        X= 2*X
        IF (X .LT. ALMAX) GOTO 210
       CONTINUE
       I= MAX(3,I)
       IF (I .GT. MAXLSQF) THEN
        PRINT *,'ATOMSCF: MAXLSQF MUST BE AT LEAST: ',I
        CALL STOPIT
       END IF
       NRPFIT(IFNCT)= I
C
C CHECK FOR SIGN CHANGE IN RHO/POT
C
       DO IRAD= 2,NRAD
        IF ((RHO (1,IRAD)*RHO (1,IRAD-1) .LT. 0.0D0) .OR.
     &      (VPOT(2,IRAD)*VPOT(2,IRAD-1) .LT. 0.0D0)) THEN
         PRINT *,'ATOMSCF: SIGN CHANGE IN RHO/POT'
         PRINT *,'MOST LIKELY YOUR LOCAL POTENTIAL CHANGES ITS SIGN'
         PRINT *,'WHICH IS A BAD, BAD THING'
         IF ((RHO (1,IRAD)*RHO (1,IRAD-1) .GT. 1.0D-10) .OR.
     &      (VPOT(2,IRAD)*VPOT(2,IRAD-1) .GT. 1.0D-10)) THEN
         CALL STOPIT
        END IF
        END IF
       END DO
C
C DENSITY FIT (USE SPACE IN VLOC AND IGNORE FIRST TWO EXPONENTS)
C RENORMALIZE DENSITY TO GET CORRECT NORM
C
       DO IRAD= 1,NRAD
        VLOC(IRAD)= RHO(1,IRAD)
       END DO
       CALL ATMFIT(4*ALMIN,NRPFIT(IFNCT)-2,NRAD,RRAD,WRAD,VLOC,
     &             MATSZ,FCOF,AMAT,AVEC,IVEC)
       RPFCMX(IFNCT)= 0.0D0
       RPFCOF(1,1,IFNCT)= 0.0D0
       RPFCOF(1,2,IFNCT)= 0.0D0
       X= 4*ALMIN 
       SUM= 0.0D0
       DO I= 1,NRPFIT(IFNCT)-2
        SUM= SUM+FCOF(I)*(SQRT(PI/X))**3
        X= 2*X
       END DO
       SUM= ZELC(IFNCT)/SUM
       DO I= 1,NRPFIT(IFNCT)-2
        FCOF(I)= FCOF(I)*SUM
        RPFCOF(1,I+2,IFNCT)= FCOF(I)
        RPFCMX(IFNCT)= MAX(RPFCMX(IFNCT),ABS(FCOF(I)))
       END DO
       PRINT '(A,F12.8,A)','CHARGE ERROR IN DENSITY FIT: ',
     &                     ZELC(IFNCT)*(SUM-1.0D0),' (CORRECTED)'
C
C POTENTIAL FIT (USE SPACE IN VLOC)
C IF THERE IS NO 1/R SINGULARITY, FIT -POT, OTHERWISE FIT -POT*R
C
       ZZ= (VPOT(2,1)-VPOT(2,2))/(1.0D0/RRAD(1)-1.0D0/RRAD(2))
       IF (ABS(ZZ) .LT. 0.1D0) THEN
        LDIVR(IFNCT)= 0
        DO IRAD= 1,NRAD
         VLOC(IRAD)= -VPOT(2,IRAD)
        END DO
       ELSE
        LDIVR(IFNCT)= 1
        DO IRAD= 1,NRAD
         VLOC(IRAD)= -VPOT(2,IRAD)*RRAD(IRAD)
         WRAD(IRAD)= WRAD(IRAD)/RRAD(IRAD)**2
        END DO
       END IF
       CALL ATMFIT(ALMIN,NRPFIT(IFNCT),NRAD,RRAD,WRAD,VLOC,
     &             MATSZ,FCOF,AMAT,AVEC,IVEC)
       DO I= 1,NRPFIT(IFNCT)
        RPFCOF(2,I,IFNCT)= FCOF(I)
        RPFCMX(IFNCT)= MAX(RPFCMX(IFNCT),ABS(FCOF(I)))
       END DO
C
C CHECK IF FITTED DENSITY / POTENTIAL HAS SIGN CHANGE
C
       IFAIL= 0
       IF (RPFCOF(1,3,IFNCT) .LT. 0.0D0) IFAIL= IFAIL+1 
       IF (RPFCOF(2,1,IFNCT) .LT. 0.0D0) IFAIL= IFAIL+1 
       IF (IFAIL .EQ. 0) THEN
        RLIMT= 0.0D0
        DO IR= 1,2
         IOFS= 3
         IF (IR .EQ. 2) IOFS= 1
         DO I= IOFS+1,NRPFIT(IFNCT)
          IF (RPFCOF(IR,I,IFNCT) .LT. 0.0D0) THEN
           RLIMT= MAX(RLIMT,
     &           (LOG(-RPFCOF(IR,I,IFNCT))-LOG(RPFCOF(IR,IOFS,IFNCT)))
     &           /(ALMIN*(2**(I-1)-2**(IOFS-1))))
          END IF
         END DO
        END DO
        RLIMT= SQRT(RLIMT)
        DLTX= 0.01D0
        NSTEP= INT(RLIMT/DLTX)
        DO ISTEP= 0,NSTEP
         CALL RPFIT(IFNCT,ISTEP*DLTX,1.0D0,RHOF,POTF)
         IF ((RHOF .LT. 0.0D0) .OR. (POTF .GT. 0.0D0)) IFAIL= IFAIL+1
        END DO
       END IF
       IF (IFAIL .NE. 0) THEN
        PRINT '(A,I8)','WARNING: DENSITY/POTENTIAL FIT CHANGES SIGN'
       ELSE
        PRINT '(A)','POTENTIAL AND DENSITY FITS ARE OK'
       END IF
C
C RESTORE ALTERED VARIABLES AND LEAVE
C
       IGGA(1)= NIGGA(1)
       IGGA(2)= NIGGA(2)
       NCNT= NNCNT
       IFUCNT(1)= NIFUCNT
       RCNT(1,1)= ORCNT(1)
       RCNT(2,1)= ORCNT(2)
       RCNT(3,1)= ORCNT(3)
       NGRP= NNGRP
       NSPN= NNSPN

C
C DEALLOCATION OF LOCAL ARRAYS (NEED TO CHECK TO SEE IF THIS IS COUNTERPRODUCTIVE TIMEWISE)
C
       DEALLOCATE(OVLTAB,STAT=IERR)
       IF(IERR.NE.0)THEN
          WRITE(6,*)'ATOMSCF:ERROR DEALLOCATING OVLTAB'
       ENDIF
       DEALLOCATE(OVLDIA,STAT=IERR)
       IF(IERR.NE.0)THEN
          WRITE(6,*)'ATOMSCF:ERROR DEALLOCATING OVLDIA'
       ENDIF
       DEALLOCATE(HKNTAB,STAT=IERR)
       IF(IERR.NE.0)THEN
          WRITE(6,*)'ATOMSCF:ERROR DEALLOCATING HKNTAB'
       ENDIF
       DEALLOCATE(HNLTAB,STAT=IERR)
       IF(IERR.NE.0)THEN
          WRITE(6,*)'ATOMSCF:ERROR DEALLOCATING HNLTAB'
       ENDIF
       DEALLOCATE(BASFU,STAT=IERR)
       IF(IERR.NE.0)THEN
          WRITE(6,*)'ATOMSCF:ERROR DEALLOCATING BASFU'
       ENDIF
       DEALLOCATE(TABEXP,STAT=IERR)
       IF(IERR.NE.0)THEN
          WRITE(6,*)'ATOMSCF:ERROR DEALLOCATING TABEXP'
       ENDIF
       DEALLOCATE(RRAD,STAT=IERR)
       IF(IERR.NE.0)THEN
          WRITE(6,*)'ATOMSCF:ERROR DEALLOCATING MAXRAD'
       ENDIF
       DEALLOCATE(WRAD,STAT=IERR)
       IF(IERR.NE.0)THEN
          WRITE(6,*)'ATOMSCF:ERROR DEALLOCATING WRAD'
       ENDIF
       DEALLOCATE(VLOC,STAT=IERR)
       IF(IERR.NE.0)THEN
          WRITE(6,*)'ATOMSCF:ERROR DEALLOCATING VLOC'
       ENDIF
       DEALLOCATE(VPOT,STAT=IERR)
       IF(IERR.NE.0)THEN
          WRITE(6,*)'ATOMSCF:ERROR DEALLOCATING VPOT'
       ENDIF
       DEALLOCATE(VXC,STAT=IERR)
       IF(IERR.NE.0)THEN
          WRITE(6,*)'ATOMSCF:ERROR DEALLOCATING VXC'
       ENDIF
       DEALLOCATE(RHO,STAT=IERR)
       IF(IERR.NE.0)THEN
          WRITE(6,*)'ATOMSCF:ERROR DEALLOCATING RHO'
       ENDIF
       DEALLOCATE(RHCL,STAT=IERR)
       IF(IERR.NE.0)THEN
          WRITE(6,*)'ATOMSCF:ERROR DEALLOCATING RHCL'
       ENDIF
       DEALLOCATE(HMAT,STAT=IERR)
       IF(IERR.NE.0)THEN
          WRITE(6,*)'ATOMSCF:ERROR DEALLOCATING HMAT'
       ENDIF
       DEALLOCATE(OMAT,STAT=IERR)
       IF(IERR.NE.0)THEN
          WRITE(6,*)'ATOMSCF:ERROR DEALLOCATING OMAT'
       ENDIF
       DEALLOCATE(EVALA,STAT=IERR)
       IF(IERR.NE.0)THEN
          WRITE(6,*)'ATOMSCF:ERROR DEALLOCATING EVALA'
       ENDIF
       DEALLOCATE(SCRV,STAT=IERR)
       IF(IERR.NE.0)THEN
          WRITE(6,*)'ATOMSCF:ERROR DEALLOCATING SCRV'
       ENDIF
       DEALLOCATE(EVTB,STAT=IERR)
       IF(IERR.NE.0)THEN
          WRITE(6,*)'ATOMSCF:ERROR DEALLOCATING EVTB'
       ENDIF
       DEALLOCATE(OCCU,STAT=IERR)
       IF(IERR.NE.0)THEN
          WRITE(6,*)'ATOMSCF:ERROR DEALLOCATING OCCU'
       ENDIF
       DEALLOCATE(AMAT,STAT=IERR)
       IF(IERR.NE.0)THEN
          WRITE(6,*)'ATOMSCF:ERROR DEALLOCATING AMAT'
       ENDIF
       DEALLOCATE(AVEC,STAT=IERR)
       IF(IERR.NE.0)THEN
          WRITE(6,*)'ATOMSCF:ERROR DEALLOCATING MATSZ'
       ENDIF
       DEALLOCATE(FCOF,STAT=IERR)
       IF(IERR.NE.0)THEN
          WRITE(6,*)'ATOMSCF:ERROR DEALLOCATING FCOF'
       ENDIF
       DEALLOCATE(NDEG,STAT=IERR)
       IF(IERR.NE.0)THEN
          WRITE(6,*)'ATOMSCF:ERROR DEALLOCATING NDEG'
       ENDIF
       DEALLOCATE(IVEC,STAT=IERR)
       IF(IERR.NE.0)THEN
          WRITE(6,*)'ATOMSCF:ERROR DEALLOCATING IVEC'
       ENDIF
       RETURN
      END
